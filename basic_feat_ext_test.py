# Example Feature Extraction from XML Files
# We count the number of specific system calls made by the programs, and use
# these as our features.

# This code requires that the unzipped training set is in a folder called "train". 

import os
from collections import Counter
try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET
import numpy as np
from scipy import sparse
import pickle
import pandas as pd

import util

TEST_DIR = "test"

call_set = set([])

def add_to_set(tree):
    for el in tree.iter():
        call = el.tag
        call_set.add(call)

def create_data_matrix(start_index, end_index, direc="test"):
    X = None
    classes = []
    ids = [] 
    i = -1
    for datafile in os.listdir(direc):
        if datafile == '.DS_Store':
            continue

        i += 1
        if i < start_index:
            continue 
        if i >= end_index:
            break

        # extract id and true class (if available) from filename
        id_str, clazz = datafile.split('.')[:2]
        ids.append(id_str)
        # add target class if this is training data
        try:
            classes.append(util.malware_classes.index(clazz))

        except ValueError:
            # we should only fail to find the label in our list of malware classes
            # if this is test data, which always has an "X" label
            assert clazz == "X"
            classes.append(-1)

        # parse file as an xml document
        tree = ET.parse(os.path.join(direc,datafile))
        add_to_set(tree)
        this_row = call_feats(tree)
        if X is None:
            X = this_row 
        else:
            X = np.vstack((X, this_row))

    return X, np.array(classes), ids

def call_feats(tree):

    all_calls = np.loadtxt('calls.txt', dtype='string' )
    
    call_counter = {}
    all_sec_c=0
    all_sec ={}
    first ={}
    last ={}
    for el in tree.iter():
        call = el.tag
        if call not in call_counter:
            call_counter[call] = 0
        else:
            call_counter[call] += 1
        if el.tag == "all_section":
            all_sec_c+=1
            inside=[]
            
            for child in el:
                inside.append(child.tag)
                if child.tag not in all_sec:
                    all_sec[child.tag] = 1
                else:
                    all_sec[child.tag] += 1   
            
            if inside[0] not in first:
                first[inside[0]] = 1
            else: 
                first[inside[0]] += 1
    
            if inside[-1] not in last:
                last[inside[-1]] = 1
            else: 
                last[inside[-1]] += 1

    call_feat_array = np.zeros(len(all_calls))
    all_sec_array = np.zeros(len(all_calls))
    first_array = np.zeros(len(all_calls))
    last_array = np.zeros(len(all_calls))
    for i in range(len(all_calls)):
        call = all_calls[i]
        call_feat_array[i] = 0
        all_sec_array[i] = 0
        first_array[i] = 0
        last_array[i] = 0
        if call in call_counter:
            call_feat_array[i] = call_counter[call]
        if call in all_sec:
            all_sec_array[i] = all_sec[call]
        if call in first:
            first_array[i] = first[call]
        if call in last:
            last_array[i] = last[call]
    feat_array = np.concatenate((call_feat_array,all_sec_array,first_array,last_array))
    feat_array = np.append(feat_array, all_sec_c) 
    return feat_array

## Feature extraction
def main():
    X_train, t_train, train_ids = create_data_matrix(0, 3724, TEST_DIR)

    df = pd.DataFrame(X_train)
    df['id'] = train_ids
    df['response'] = t_train
    print df.shape
    df.to_csv("test_feat.csv")

if __name__ == "__main__":
    main()
    